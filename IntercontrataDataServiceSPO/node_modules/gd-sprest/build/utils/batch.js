"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Batch = void 0;
var lib_1 = require("../lib");
var _1 = require(".");
/**
 * Batch Requests
 */
var Batch = /** @class */ (function () {
    function Batch() {
    }
    // Method to execute a batch request
    Batch.execute = function (base, args) {
        var createFl = false;
        var callback = null;
        // Parse the arguments
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            // Check the type
            switch (typeof (arg)) {
                case "boolean":
                    // Set the create flag
                    createFl = arg;
                    break;
                case "function":
                    // Set the callback method
                    callback = arg;
                    break;
            }
        }
        // Set the base
        base.base = base.base ? base.base : base;
        // See if we are creating a new request
        if (createFl || base.base.batchRequests == null) {
            // Ensure the batch requests exist
            base.base.batchRequests = base.base.batchRequests || [];
            // Create the request
            base.base.batchRequests.push([{
                    callback: callback,
                    changesetId: lib_1.ContextInfo.generateGUID(),
                    targetInfo: new _1.TargetInfo(base.targetInfo)
                }]);
        }
        else {
            // Append the request
            base.base.batchRequests[base.base.batchRequests.length - 1].push({
                callback: callback,
                changesetId: lib_1.ContextInfo.generateGUID(),
                targetInfo: new _1.TargetInfo(base.targetInfo)
            });
        }
        // Return this object
        return base;
    };
    // Method to generate a batch request
    Batch.getTargetInfo = function (url, requests) {
        var batchId = "batch_" + lib_1.ContextInfo.generateGUID();
        var batchRequests = [];
        // Create the batch request
        batchRequests.push(Batch.createBatch(batchId, requests));
        // End the batch request
        batchRequests.push("--" + batchId + "--");
        // Return the target information
        return new _1.TargetInfo({
            url: url,
            endpoint: "$batch",
            method: "POST",
            data: batchRequests.join("\r\n"),
            requestHeader: {
                "Content-Type": 'multipart/mixed; boundary="' + batchId + '"'
            }
        });
    };
    // Method to generate a batch request
    Batch.createBatch = function (batchId, requests) {
        var batch = [];
        // Parse the requests
        for (var i = 0; i < requests.length; i++) {
            var request_1 = requests[i];
            // Create the batch request
            batch.push("--" + batchId);
            // Determine if the batch requires a change set
            var requiresChangeset = request_1 && request_1.targetInfo.requestMethod != "GET";
            if (requiresChangeset) {
                // Create a change set
                batch.push("Content-Type: multipart/mixed; boundary=" + request_1.changesetId);
                batch.push("");
                batch.push("--" + request_1.changesetId);
                batch.push("Content-Type: application/http");
                batch.push("Content-Transfer-Encoding: binary");
                batch.push("");
                batch.push(request_1.targetInfo.requestMethod + " " + request_1.targetInfo.requestUrl + " HTTP/1.1");
                batch.push("Content-Type: application/json;odata=verbose");
                // See if we are making a delete/update
                if (request_1.targetInfo.requestMethod == "DELETE" || request_1.targetInfo.requestMethod == "MERGE") {
                    // Append the header for deleting/updating
                    batch.push("IF-MATCH: *");
                }
                batch.push("");
                request_1.targetInfo.requestData ? batch.push(request_1.targetInfo.requestData) : null;
                batch.push("");
                batch.push("--" + request_1.changesetId + "--");
            }
            else {
                // Create a change set
                batch.push("Content-Type: application/http");
                batch.push("Content-Transfer-Encoding: binary");
                batch.push("");
                batch.push("GET " + request_1.targetInfo.requestUrl + " HTTP/1.1");
                batch.push("Accept: application/json;odata=verbose");
                batch.push("");
                request_1.targetInfo.requestData ? batch.push(request_1.targetInfo.requestData) : null;
                batch.push("");
            }
        }
        // Add the change set information to the batch
        var batchRequest = batch.join("\r\n");
        var request = [];
        request.push("Content-Type: multipart/mixed; boundary=" + batchId);
        request.push("Content-Length: " + batchRequest.length);
        request.push("");
        request.push(batchRequest);
        request.push("");
        // Return the batch request
        return request.join("\r\n");
    };
    // Process the batch request callbacks
    Batch.processCallbacks = function (batchRequests) {
        if (batchRequests === void 0) { batchRequests = []; }
        // Parse the requests
        for (var i = 0; i < batchRequests.length; i++) {
            var batchRequest = batchRequests[i];
            // See if a callback exists
            if (batchRequest.callback) {
                // Execute the callback
                batchRequest.callback(batchRequest.response, batchRequest.targetInfo);
            }
        }
    };
    return Batch;
}());
exports.Batch = Batch;
